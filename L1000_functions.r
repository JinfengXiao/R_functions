# This script implements some functions for calling.

suppressMessages(require(stringr));
suppressMessages(require(MASS));

# This function reads in Sheng's low dimensional representations of GO terms and processes them for my purpose. The input is the directory of file to read. The output is a matrix, each row being a GO term and each column being a component of the low dimensional representation.
read_sheng = function(dir){
  go_emb = read.table(dir);
  rownames(go_emb) = str_replace_all(go_emb[,1],":","_");
  go_emb = go_emb[,-1];
  go_emb = as.matrix(go_emb);
  colnames(go_emb) = NULL;
  return(go_emb);
}

# This function is to simulate the effect of random clustering on the number of shared edges.
# Inputs:
#   pert_c: Generated by the function cluster_p_value
#   ns: number of simulations
n_cross_edges_random_split = function (pert_c, ns = 1000) {
  n_cluster = max(as.integer(pert_c[, "cluster"]))
  pert_id_uniq = unique(pert_c[, "pert_id"])
  cross_edges = rep(0, ns)
  for(i in 1 : ns){
    # Randomly permute the assigned clusters
    pert_c[, "cluster"] = pert_c[sample(nrow(pert_c)), "cluster"]
    for(j in 1 : length(pert_id_uniq)){
      exp_c = pert_c[pert_c[, "pert_id"] == pert_id_uniq[j], "cluster"]
      total_edges = length(exp_c) * (length(exp_c) - 1) / 2
      n_intra_edges = 0
      for(k in 1 : n_cluster){
        n_intra_edges = n_intra_edges + sum(exp_c == k) ^ 2
      }
      cross_edges[i] = cross_edges[i] + total_edges - n_intra_edges
    }
  }
  return(cross_edges)
}

# This function reads in deg and convert it to an integer matrix whose rows are experiments and columns are ensembl IDs. Each entry is either 1 or 0. 1 means deg, 0 means not.
build_deg_matrix = function(deg){
  gene_v = unique(deg[,"ensembl_id"]);
  exp_v = unique(deg[,"exp_id"]);
  deg_m = matrix(0L,length(exp_v),length(gene_v));
  rownames(deg_m) = exp_v;
  colnames(deg_m) = gene_v;
  for(i in 1:nrow(deg_m)){
    deg_per_exp = deg[grep(exp_v[i],deg[,"exp_id"]),];
    deg_m[i,deg_per_exp[,"ensembl_id"]] = rep(1L,length(deg_per_exp[,"ensembl_id"]));
  }
  return(deg_m);
}

# This function takes in a matrix m and the pert_c matrix, performs row-based PCA analysis and makes a plot.
pca_plot = function(m,pert_c){
  pca = prcomp(m)$x;
  pca_dmso = pca[grep("ctl",pert_c[,"pert_type"]),];
  pca_others = pca[!grepl("ctl",pert_c[,"pert_type"]),];
  pca_cluster1 = pca[(!grepl("ctl",pert_c[,"pert_type"]))&(pert_c[,"cluster"]=="1"),];
  pca_cluster2 = pca[(!grepl("ctl",pert_c[,"pert_type"]))&(pert_c[,"cluster"]=="2"),];
  plot(pca[,1:2],type="p",col="grey",pch=20,cex=0.1); # For getting x and y ranges only
  points(pca_cluster1[,1:2],type="p",col="gold",pch=20);
  points(pca_cluster2[,1:2],type="p",col="green",pch=20);
  points(pca_dmso[,1:2],type="p",col="black",pch=20,cex=1.5);
}

# This function takes in 2 cluster assignment vectors of the same length, and calculates the Rand index. Each input vector contains integers 1 and 2 only.
rand_index = function(c1,c2){
  stopifnot(length(c1)==length(c2));
  n = length(c1);
  count = 0;
  for(i in 1:(n-1)){
    pair_c1 = (c1[(i+1):n]+c1[i])%%2;
    pair_c2 = (c2[(i+1):n]+c2[i])%%2;
    compare = pair_c1+pair_c2;
    count = count+length(grep(0,compare))+length(grep(2,compare));
  }
  denominator = n*(n-1)/2;
  return(count/denominator);
}

# This function takes in a pert or pert_c matrix, and integrates dose and time info into "pert_id" column.
pert_dose_time_to_id = function(pert){
  pert[,"pert_id"] = paste(pert[,"pert_id"],pert[,"pert_dose"],pert[,"pert_time"],sep="_");
  return(pert);
}

# This function builds a binary enrichment score matrix from a real enrichment score matrix.
build_enrich_scores_binary = function(enrich_scores,threshold){
  enrich_scores_binary = matrix(1L,nrow(enrich_scores),ncol(enrich_scores));
  rownames(enrich_scores_binary) = rownames(enrich_scores);
  colnames(enrich_scores_binary) = colnames(enrich_scores);
  for(i in 1:nrow(enrich_scores)){
    flag = (enrich_scores[i,]<threshold);
    enrich_scores_binary[i,flag] = rep(0L,sum(flag));
  }
  return(enrich_scores_binary);
}

# This function converts a binary enrich score matrix to a embedding score matrix.
build_emb_score = function(enrich_scores_binary, go_emb){
  go_emb = go_emb[rownames(go_emb)%in%colnames(enrich_scores_binary),];
  enrich_scores_binary = enrich_scores_binary[,colnames(enrich_scores_binary)%in%rownames(go_emb)];
  rownames(go_emb) = str_replace_all(rownames(go_emb),"GO_","");
  colnames(enrich_scores_binary) = str_replace_all(colnames(enrich_scores_binary),"GO_","");
  go_emb = go_emb[order(as.integer(rownames(go_emb))),];
  enrich_scores_binary = enrich_scores_binary[,order(as.integer(colnames(enrich_scores_binary)))];
  if(!identical(rownames(go_emb),colnames(enrich_scores_binary))){stop("Error in function build_emb_score!");}
  return(enrich_scores_binary %*% go_emb);
}

# This function performs a hypergeometric test, and returns a real matrix to store the enrichment test results. In the matrix, each row is a unique experiment. Each column is a GO term. Each entry is -logP of the hypergeometric test.
hypergeo_test = function(deg, ensembl_go_table, threshold){
  uniq_exp = unique(deg[, "exp_id"]);
  enrich_scores = matrix(F, length(uniq_exp), ncol(ensembl_go_table));
  rownames(enrich_scores) = uniq_exp;
  colnames(enrich_scores) = colnames(ensembl_go_table);
  for(i in 1:nrow(enrich_scores)){
    deg_list_per_exp = deg[deg[, "exp_id"] == uniq_exp[i], "ensembl_id"];
    for(j in 1:ncol(enrich_scores)){
      gene_list_per_go = rownames(ensembl_go_table)[ensembl_go_table[, j]];
      deg_list_per_go_per_exp = deg_list_per_exp[deg_list_per_exp %in% gene_list_per_go];
      #enrich_scores[i, j] = - phyper(length(deg_list_per_go_per_exp) - 1, length(deg_list_per_exp), nrow(ensembl_go_table) - length(deg_list_per_exp), length(gene_list_per_go), lower.tail=F, log.p=T);
      enrich_scores[i, j] = - phyper(length(deg_list_per_go_per_exp) - 1, length(gene_list_per_go), nrow(ensembl_go_table) - length(gene_list_per_go), length(deg_list_per_exp), lower.tail=F, log.p=T);
    }
  }
  return(enrich_scores);
}

# This function calculates the p-value based on the number of cross edges.
cluster_p_value = function(hc, pert, n_cluster = 2){
  cluster = cutree(hc, n_cluster);
  
  pert_c = cbind(pert, cluster[pert[, "exp_id"]])
  colnames(pert_c)[ncol(pert_c)] = "cluster"
  pert_c = pert_c[!grepl("DMSO", pert_c[,"pert_id"]), ] # Remove control experiments
  pert_c = pert_dose_time_to_id(pert_c);
  #pca_plot(enrich_scores_binary,pert_c);
  
  pert_id_uniq = unique(pert_c[,"pert_id"]);
  edge_num = matrix(0, length(pert_id_uniq), 3);
  colnames(edge_num) = c("n_exp", "n_edges", "n_cross_edges");
  for(i in 1:length(pert_id_uniq)){
    exp_c = pert_c[pert_c[, "pert_id"] == pert_id_uniq[i], "cluster"];
    edge_num[i, "n_exp"] = length(exp_c);
    edge_num[i, "n_edges"] = length(exp_c) * (length(exp_c) - 1) / 2;
    n_intra_edges = 0;
    for(j in 1:n_cluster){
      n_intra_edges = n_intra_edges + sum(exp_c == j) ^ 2;
    }
    edge_num[i, "n_cross_edges"] = edge_num[i, "n_edges"] - n_intra_edges;
  }
  
  N = nrow(pert_c);
  n = rep(0, n_cluster);
  for(i in 1:n_cluster){
    n[i] = sum(pert_c[,"cluster"] == i);
  }
  NE = sum(edge_num[, "n_edges"]);  # Total number of edges
  E_n_cross_edges = 0; # Expected number of cross-cluster edges
  for (i in 1 : (n_cluster - 1)) {
    for( j in i : n_cluster) {
      E_n_cross_edges = E_n_cross_edges + n[i] * n[j];
    }
  }
  E_n_cross_edges = E_n_cross_edges * 2 * NE / (N ^ 2);
  
  n_cross_edges = sum(edge_num[, "n_cross_edges"]);
  
  n_cross_edges_sim = n_cross_edges_random_split(pert_c, ns = 1000);
  dist = fitdistr(n_cross_edges_sim, "normal")$estimate;
  p_value = pnorm(q = n_cross_edges, mean = dist[1], sd = dist[2]);
  return(p_value);
}